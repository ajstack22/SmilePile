{"context": "\n## File: 02_WORKFLOWS/01_RESEARCH_PROCESS.md\n# Research Process\n\n## Overview\nA comprehensive multi-agent research process that transforms vague questions into actionable knowledge through systematic, parallel investigation across technical, business, user, and risk dimensions. The Orchestrator coordinates multiple specialized research agents to provide deep insights for informed decision-making.\n\n## When to Use\n- Evaluating new technologies or approaches\n- Making architectural decisions\n- Understanding market opportunities\n- Investigating technical feasibility\n- Comparing multiple options\n- Solving complex problems\n- Reducing uncertainty before commitment\n\n## Process Script\n**Script**: `automation/processes/research.py`\n**Usage**:\n```bash\npython research.py \"React Native performance\" --full        # 5+ agents, deep dive\npython research.py \"GraphQL vs REST\" --quick               # 2 agents, rapid\npython research.py \"Cloud providers\" --comparative         # Comparison matrix\n```\n\n## Process Owner\n**Role**: ORCHESTRATOR\n- Orchestrator coordinates all research agents\n- Never researches directly\n- Synthesizes findings from multiple agents\n- Makes strategic recommendations\n\n## The Multi-Agent Research Architecture\n\n### Agent Constellation\n```\n            ORCHESTRATOR\n                 |\n    +------------+------------+\n    |            |            |\nTechnical    Business      User\nResearcher   Researcher   Researcher\n    |            |            |\n    +------------+------------+\n         |              |\n   Implementation    Risk\n     Researcher    Researcher\n```\n\n### The 5 Specialized Research Agents\n\n#### Agent 1: Technical Researcher\n**Mission**: Deep technical investigation\n- Current implementations and patterns\n- Technical best practices\n- Common pitfalls and anti-patterns\n- Performance implications\n- Security considerations\n- Technical dependencies\n**Returns**: Technical feasibility assessment\n\n#### Agent 2: Business & Market Researcher\n**Mission**: Business and market context\n- Market trends and adoption\n- Competitor approaches\n- ROI calculation and costs\n- Business risks and opportunities\n- Regulatory/compliance factors\n- Case studies and success stories\n**Returns**: Business impact analysis\n\n#### Agent 3: User Experience Researcher\n**Mission**: User perspective investigation\n- User needs and pain points\n- Common user workflows\n- Usability best practices\n- Accessibility requirements\n- User feedback and reviews\n- Journey scenarios\n**Returns**: User impact assessment\n\n#### Agent 4: Implementation Researcher\n**Mission**: Practical implementation analysis\n- Existing code patterns\n- Implementation examples\n- Required tools and frameworks\n- Effort and complexity analysis\n- Migration strategies\n- Testing approaches\n**Returns**: Implementation roadmap\n\n#### Agent 5: Risk & Compliance Researcher\n**Mission**: Risk and compliance assessment\n- Security vulnerabilities\n- Compliance requirements\n- Failure modes and edge cases\n- Operational risks\n- Legal implications\n- Disaster recovery needs\n**Returns**: Risk matrix with mitigations\n\n## The 6-Phase Research Process\n\n### Phase 1: Research Planning\n**Orchestrator Actions**:\n1. Decompose topic into research questions\n2. Identify research dimensions\n3. Plan agent missions\n4. Set success criteria\n\n**Fundamental Questions**:\n- What problem does this solve?\n- Who are the stakeholders?\n- What are current solutions?\n- What defines success?\n- What are the constraints?\n\n**Research Dimensions**:\n- Technical feasibility\n- Business value\n- User experience\n- Security implications\n- Performance factors\n- Operational aspects\n\n**Success Criteria**:\n- Questions clearly defined\n- Dimensions identified\n- Agent missions planned\n\n### Phase 2: Multi-Agent Deployment\n**Orchestrator Actions**:\n1. Spawn all 5 research agents IN PARALLEL\n2. Monitor agent progress\n3. Handle agent failures\n4. Await all completions\n\n**Parallel Execution**:\n```python\n# All agents launch simultaneously\nUse Task tool with general-purpose agents:\n- Technical Researcher \u2192 Technical investigation\n- Business Researcher \u2192 Market analysis\n- UX Researcher \u2192 User research\n- Implementation Researcher \u2192 Practical analysis\n- Risk Researcher \u2192 Risk assessment\n```\n\n**Success Criteria**:\n- All agents successfully spawned\n- Research proceeding in parallel\n- No blocking dependencies\n\n### Phase 3: Correlation & Synthesis\n**Orchestrator Actions**:\n1. Gather all agent outputs\n2. Identify agreements (high confidence)\n3. Identify conflicts (needs investigation)\n4. Find patterns across domains\n5. Map dependencies\n\n**Correlation Analysis**:\n- Agreement points \u2192 High confidence findings\n- Disagreements \u2192 Further investigation needed\n- Emerging patterns \u2192 Key insights\n- Dependencies \u2192 Implementation considerations\n- Knowledge gaps \u2192 Open questions\n\n**Pattern Recognition**:\n- Common challenges across agents\n- Convergent success factors\n- Recurring warnings\n- Unanimous recommendations\n\n**Success Criteria**:\n- All findings correlated\n- Patterns identified\n- Conflicts noted\n\n### Phase 4: Deep Dive Investigation\n**Orchestrator Actions**:\n1. Identify 2-3 critical areas\n2. Spawn specialized deep-dive agents\n3. Focus on highest-impact findings\n4. Resolve conflicts from Phase 3\n\n**Critical Areas** (typically):\n- Most critical technical challenge\n- Biggest business opportunity/risk\n- Primary user concern\n\n**Deep Research Activities**:\n- Code pattern analysis\n- Detailed cost modeling\n- User testing scenarios\n- Security vulnerability assessment\n\n**Success Criteria**:\n- Critical areas thoroughly investigated\n- Conflicts resolved\n- High-impact findings validated\n\n### Phase 5: Recommendations & Reporting\n**Orchestrator Actions**:\n1. Synthesize all findings\n2. Create recommendations\n3. Assign confidence levels\n4. Generate comprehensive report\n\n**Report Structure**:\n```markdown\n# Research Report: [Topic]\n\n## Executive Summary\n[2-3 paragraphs of key findings]\n\n## Key Findings\n### Technical\n- Finding [Evidence] [Confidence: High/Med/Low]\n\n### Business\n- Finding [Evidence] [Confidence: High/Med/Low]\n\n### User Experience\n- Finding [Evidence] [Confidence: High/Med/Low]\n\n## Patterns and Insights\n[Cross-domain patterns]\n\n## Risk Assessment\n| Risk | Probability | Impact | Mitigation |\n\n## Recommendations\n### Immediate Actions (This Sprint)\n### Short-term (Next Month)\n### Strategic (Long-term)\n\n## Implementation Roadmap\n[Phased approach if applicable]\n\n## Open Questions\n[What needs more research]\n\n## Confidence Assessment\nOverall: High/Medium/Low\nRationale: [Why this level]\n```\n\n**Success Criteria**:\n- Comprehensive report generated\n- Clear recommendations provided\n- Confidence levels assigned\n\n### Phase 6: Knowledge Preservation\n**Orchestrator Actions**:\n1. Archive all research artifacts\n2. Update knowledge base\n3. Document decision rationale\n4. Create follow-up tasks\n\n**Preservation Activities**:\n- Save agent reports\n- Archive evidence\n- Document decisions\n- Update team wiki\n- Create research backlog\n\n**Success Criteria**:\n- All artifacts preserved\n- Knowledge accessible\n- Follow-ups identified\n\n## Script Details\n\n### Research Modes\n\n#### Full Research (--full)\n- Deploys all 5 agents\n- 6 complete phases\n- 2-4 hour investigation\n- Comprehensive report\n\n#### Quick Research (--quick)\n- 2 agents only (Technical + Business)\n- Rapid 30-minute scan\n- Concise findings\n- Go/no-go recommendation\n\n#### Comparative Research (--comparative)\n- Specialized comparison agents\n- Feature matrices\n- Trade-off analysis\n- Clear winner identification\n\n### State Management\nResearch state in `.atlas/research/`:\n```json\n{\n  \"research_id\": \"R20240115143000\",\n  \"topic\": \"microservices migration\",\n  \"phase\": \"synthesis\",\n  \"agents_spawned\": 5,\n  \"agents_completed\": 3,\n  \"findings\": {\n    \"technical\": [...],\n    \"business\": [...],\n    \"risks\": [...]\n  }\n}\n```\n\n## Research Quality Metrics\n\n### Coverage Metrics\n- All dimensions explored: \u2713\n- Multiple perspectives gathered: \u2713\n- Edge cases considered: \u2713\n- Risks identified: \u2713\n\n### Depth Metrics\n- Critical areas investigated: \u2713\n- Evidence provided: \u2713\n- Examples found: \u2713\n- Patterns recognized: \u2713\n\n### Synthesis Quality\n- Insights exceed individual findings: \u2713\n- Conflicts resolved: \u2713\n- Clear recommendations: \u2713\n- Actionable next steps: \u2713\n\n## Common Research Topics\n\n### Technical Research\n- \"Microservices architecture patterns\"\n- \"React vs Vue.js for enterprise\"\n- \"Database migration strategies\"\n- \"CI/CD pipeline optimization\"\n- \"API design patterns\"\n\n### Business Research\n- \"Market opportunity for feature X\"\n- \"Competitor pricing analysis\"\n- \"Cost-benefit of cloud migration\"\n- \"Partnership evaluation\"\n- \"Product-market fit analysis\"\n\n### Strategic Research\n- \"AI integration opportunities\"\n- \"Technical debt prioritization\"\n- \"Platform modernization\"\n- \"Security posture assessment\"\n- \"Scalability planning\"\n\n## Success Metrics\n\n- **Comprehensiveness**: All angles explored\n- **Accuracy**: Findings verified correct\n- **Actionability**: Clear next steps identified\n- **Timeliness**: Delivered within useful window\n- **Clarity**: Complex topics made understandable\n- **Impact**: Decisions improved by research\n\n## Integration Points\n\n- **Output**: Research reports for decision-making\n- **Input**: Questions from stakeholders\n- **Integrates with**:\n  - Story Creation (feasibility research)\n  - Troubleshooting (pattern research)\n  - Adversarial Workflow (implementation research)\n\n## The Power of Orchestrated Research\n\n**Traditional Research**:\n- Single perspective\n- Linear investigation\n- Limited depth\n- 4-8 hours for comprehensive research\n\n**Orchestrated Multi-Agent Research**:\n- 5+ perspectives simultaneously\n- Parallel investigation\n- Unlimited depth per agent\n- 1-2 hours for comprehensive research\n\n**Multiplication Effect**:\n- 5x faster (parallel vs sequential)\n- 5x broader (multiple specializations)\n- 5x deeper (focused expertise)\n- 5x better (synthesis creates insights)\n\nThe Orchestrator coordinates this research symphony, creating understanding that no single researcher could achieve alone.\n\n## File: 07_AUTOMATION/01_research.py\n#!/usr/bin/env python3\n\"\"\"\nAtlas Research Script - Designed to be called by Claude Orchestrator\nThis script performs actual research tasks and returns results to Claude\n\"\"\"\n\nimport sys\nimport json\nimport os\nimport subprocess\nfrom pathlib import Path\nfrom datetime import datetime\n\nclass ResearchAgent:\n    \"\"\"\n    A research agent that Claude can invoke to perform specific research tasks\n    \"\"\"\n\n    def __init__(self):\n        self.state_dir = Path('.atlas/research')\n        self.state_dir.mkdir(parents=True, exist_ok=True)\n        self.results = {}\n\n    def search_codebase(self, pattern, file_type=\"*\"):\n        \"\"\"\n        Search codebase for patterns\n        Returns: List of matches with file and line number\n        \"\"\"\n        results = []\n        try:\n            # Use ripgrep for fast searching\n            cmd = f\"rg '{pattern}' --type-add 'custom:{file_type}' -t custom --json\"\n            output = subprocess.run(cmd, shell=True, capture_output=True, text=True)\n\n            for line in output.stdout.split('\\n'):\n                if line:\n                    try:\n                        data = json.loads(line)\n                        if data.get('type') == 'match':\n                            results.append({\n                                'file': data['data']['path']['text'],\n                                'line': data['data']['line_number'],\n                                'text': data['data']['lines']['text'].strip()\n                            })\n                    except:\n                        continue\n        except Exception as e:\n            results.append({'error': str(e)})\n\n        return results\n\n    def analyze_structure(self, directory=\".\"):\n        \"\"\"\n        Analyze project structure\n        Returns: Dictionary of project organization\n        \"\"\"\n        structure = {\n            'languages': {},\n            'frameworks': [],\n            'config_files': [],\n            'test_framework': None,\n            'build_system': None\n        }\n\n        # Detect languages by extension\n        extensions = {}\n        for root, dirs, files in os.walk(directory):\n            # Skip hidden and node_modules\n            dirs[:] = [d for d in dirs if not d.startswith('.') and d != 'node_modules']\n\n            for file in files:\n                ext = Path(file).suffix\n                if ext:\n                    extensions[ext] = extensions.get(ext, 0) + 1\n\n        # Map extensions to languages\n        lang_map = {\n            '.py': 'Python',\n            '.js': 'JavaScript',\n            '.ts': 'TypeScript',\n            '.java': 'Java',\n            '.go': 'Go',\n            '.rs': 'Rust',\n            '.cpp': 'C++',\n            '.c': 'C'\n        }\n\n        for ext, count in extensions.items():\n            if ext in lang_map:\n                structure['languages'][lang_map[ext]] = count\n\n        # Detect frameworks and tools\n        if os.path.exists('package.json'):\n            structure['frameworks'].append('Node.js')\n            with open('package.json', 'r') as f:\n                pkg = json.load(f)\n                deps = list(pkg.get('dependencies', {}).keys())\n                if 'react' in deps:\n                    structure['frameworks'].append('React')\n                if 'vue' in deps:\n                    structure['frameworks'].append('Vue')\n                if 'express' in deps:\n                    structure['frameworks'].append('Express')\n                if 'jest' in deps or 'mocha' in deps:\n                    structure['test_framework'] = 'Jest/Mocha'\n\n        if os.path.exists('requirements.txt') or os.path.exists('Pipfile'):\n            structure['frameworks'].append('Python')\n            if os.path.exists('manage.py'):\n                structure['frameworks'].append('Django')\n\n        if os.path.exists('go.mod'):\n            structure['frameworks'].append('Go Modules')\n\n        if os.path.exists('Cargo.toml'):\n            structure['frameworks'].append('Rust/Cargo')\n\n        # Detect build system\n        if os.path.exists('Makefile'):\n            structure['build_system'] = 'Make'\n        elif os.path.exists('webpack.config.js'):\n            structure['build_system'] = 'Webpack'\n        elif os.path.exists('vite.config.js'):\n            structure['build_system'] = 'Vite'\n\n        return structure\n\n    def find_similar_implementations(self, pattern):\n        \"\"\"\n        Find similar patterns in codebase\n        Returns: List of similar implementations\n        \"\"\"\n        # This would search for similar patterns\n        results = self.search_codebase(pattern)\n\n        # Group by file\n        by_file = {}\n        for match in results:\n            if 'file' in match:\n                file = match['file']\n                if file not in by_file:\n                    by_file[file] = []\n                by_file[file].append(match)\n\n        return {\n            'total_matches': len(results),\n            'files_affected': len(by_file),\n            'matches_by_file': by_file\n        }\n\n    def research_dependencies(self):\n        \"\"\"\n        Analyze project dependencies\n        Returns: Dependency information\n        \"\"\"\n        deps = {\n            'direct': [],\n            'dev': [],\n            'security_issues': [],\n            'outdated': []\n        }\n\n        # Check Node.js dependencies\n        if os.path.exists('package.json'):\n            with open('package.json', 'r') as f:\n                pkg = json.load(f)\n                deps['direct'] = list(pkg.get('dependencies', {}).keys())\n                deps['dev'] = list(pkg.get('devDependencies', {}).keys())\n\n        # Check Python dependencies\n        if os.path.exists('requirements.txt'):\n            with open('requirements.txt', 'r') as f:\n                deps['direct'].extend([\n                    line.split('==')[0].strip()\n                    for line in f.readlines()\n                    if line.strip() and not line.startswith('#')\n                ])\n\n        return deps\n\n    def save_research_results(self, topic, results):\n        \"\"\"Save research results for future reference\"\"\"\n        timestamp = datetime.now().isoformat()\n        filename = f\"research_{topic.replace(' ', '_')}_{timestamp}.json\"\n        filepath = self.state_dir / filename\n\n        with open(filepath, 'w') as f:\n            json.dump({\n                'topic': topic,\n                'timestamp': timestamp,\n                'results': results\n            }, f, indent=2)\n\n        return str(filepath)\n\n    def execute_research(self, topic, research_type='full'):\n        \"\"\"\n        Main research execution - Called by Claude\n\n        Args:\n            topic: What to research\n            research_type: 'full', 'quick', 'structural', 'dependencies'\n\n        Returns:\n            JSON string with research results\n        \"\"\"\n        results = {\n            'topic': topic,\n            'type': research_type,\n            'timestamp': datetime.now().isoformat(),\n            'findings': {}\n        }\n\n        if research_type in ['full', 'structural']:\n            results['findings']['structure'] = self.analyze_structure()\n\n        if research_type in ['full', 'dependencies']:\n            results['findings']['dependencies'] = self.research_dependencies()\n\n        if research_type == 'full':\n            # Search for topic-related patterns\n            results['findings']['code_references'] = self.search_codebase(topic)\n            results['findings']['similar_patterns'] = self.find_similar_implementations(topic)\n\n        # Save results\n        saved_path = self.save_research_results(topic, results)\n        results['saved_to'] = saved_path\n\n        return json.dumps(results, indent=2)\n\ndef main():\n    \"\"\"\n    Entry point when Claude runs this script\n\n    Usage:\n        python 01_research.py --topic \"authentication\" --type full\n        python 01_research.py --analyze-structure\n        python 01_research.py --search \"pattern\" --file-type \"*.js\"\n    \"\"\"\n    agent = ResearchAgent()\n\n    # Parse command line arguments\n    args = sys.argv[1:]\n\n    if '--topic' in args:\n        idx = args.index('--topic')\n        topic = args[idx + 1] if idx + 1 < len(args) else 'general'\n\n        research_type = 'full'\n        if '--type' in args:\n            type_idx = args.index('--type')\n            research_type = args[type_idx + 1] if type_idx + 1 < len(args) else 'full'\n\n        # Execute research and print results for Claude to parse\n        results = agent.execute_research(topic, research_type)\n        print(results)\n\n    elif '--analyze-structure' in args:\n        structure = agent.analyze_structure()\n        print(json.dumps(structure, indent=2))\n\n    elif '--search' in args:\n        idx = args.index('--search')\n        pattern = args[idx + 1] if idx + 1 < len(args) else ''\n\n        file_type = \"*\"\n        if '--file-type' in args:\n            type_idx = args.index('--file-type')\n            file_type = args[type_idx + 1] if type_idx + 1 < len(args) else \"*\"\n\n        results = agent.search_codebase(pattern, file_type)\n        print(json.dumps(results, indent=2))\n\n    elif '--dependencies' in args:\n        deps = agent.research_dependencies()\n        print(json.dumps(deps, indent=2))\n\n    else:\n        # Return usage information\n        usage = {\n            'script': '01_research.py',\n            'description': 'Research agent for codebase analysis',\n            'commands': [\n                {\n                    'command': '--topic [topic] --type [full|quick|structural]',\n                    'description': 'Research a specific topic'\n                },\n                {\n                    'command': '--analyze-structure',\n                    'description': 'Analyze project structure'\n                },\n                {\n                    'command': '--search [pattern] --file-type [pattern]',\n                    'description': 'Search codebase for patterns'\n                },\n                {\n                    'command': '--dependencies',\n                    'description': 'Analyze project dependencies'\n                }\n            ]\n        }\n        print(json.dumps(usage, indent=2))\n\nif __name__ == \"__main__\":\n    main()\n", "metadata": {"task": "research", "feature": null, "timestamp": "2025-09-19T20:52:12.990758", "files_included": [{"path": "02_WORKFLOWS/01_RESEARCH_PROCESS.md", "size": 9982, "priority": 1}, {"path": "07_AUTOMATION/01_research.py", "size": 10124, "priority": 2}], "files_excluded": [], "dependencies_resolved": [], "total_tokens": 5048, "cache_key": "7412df2b1db8cd2a5d4aafdb6c2090d3", "total_size": 20193}}