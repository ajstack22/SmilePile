#!/usr/bin/env python3
"""
Atlas Bug Workflow Kickoff Script
Automatically initiates the complete Atlas bug resolution workflow with context injection
"""

import sys
import json
import os
from pathlib import Path
from datetime import datetime
import argparse

# Add automation directory to path
script_dir = Path(__file__).parent
automation_path = script_dir / '07_AUTOMATION'
sys.path.insert(0, str(automation_path))

from task_context_integration import TaskContextIntegration
from enhanced_context_injector import EnhancedContextInjector

def create_bug_story(bug_description: str, app_area: str = "General") -> str:
    """Create a new bug story with Atlas format"""

    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    story_id = f"BUG-{timestamp}"

    # Extract key details from description
    title = bug_description.split('.')[0].strip().replace(' ', '-').lower()[:50]
    story_filename = f"{story_id}-{title}.md"
    story_path = Path(__file__).parent / '09_STORIES' / 'bugs' / story_filename

    story_template = f"""# {story_id}: {bug_description.split('.')[0]}

## Status: IN_PROGRESS

## Problem Statement
**User Report**: {bug_description}

**Area**: {app_area}

## Bug Details
- **Severity**: HIGH (Crash/Blocking Issue)
- **First Reported**: {datetime.now().isoformat()}
- **Status**: IN_PROGRESS

## Steps to Reproduce
1. [TO BE DETERMINED - Needs investigation]
2.
3.

## Expected Behavior
[TO BE DETERMINED after investigation]

## Actual Behavior
{bug_description}

## Root Cause Analysis
‚ö†Ô∏è **PENDING INVESTIGATION**

## Proposed Solution
‚ö†Ô∏è **TO BE DETERMINED after root cause analysis**

## Testing Requirements
- [ ] Reproduce the issue locally
- [ ] Verify fix resolves the issue
- [ ] Add regression test
- [ ] Test edge cases
- [ ] Verify no side effects

## Evidence Requirements
- [ ] Screenshot/video of issue before fix
- [ ] Screenshot/video showing issue resolved
- [ ] Test results showing fix works
- [ ] Code review approval

## Atlas Workflow Checklist
- [ ] Bug reproduced locally
- [ ] Root cause identified
- [ ] Fix implemented
- [ ] Tests written
- [ ] Documentation updated
- [ ] Ready for validation

---
*Generated by Atlas Bug Workflow - {datetime.now().isoformat()}*
"""

    # Ensure bugs directory exists
    story_path.parent.mkdir(parents=True, exist_ok=True)

    # Write story
    with open(story_path, 'w') as f:
        f.write(story_template)

    return str(story_path)

def inject_bug_context_and_checklist():
    """Get the troubleshooting context and checklist"""

    injector = EnhancedContextInjector()
    result = injector.build_context(task='troubleshooting', verbose=False)

    return result['context'], result['metadata']

def format_workflow_prompt(bug_description: str, story_path: str, context: str) -> str:
    """Create the structured prompt for the LLM"""

    prompt = f"""
# üö® ATLAS BUG WORKFLOW INITIATED

## Bug Report
{bug_description}

## Bug Story Created
üìù Story: {story_path}

## Your Atlas Workflow Tasks

### Phase 1: Investigation & Reproduction
1. Review the bug story file: {story_path}
2. Locate relevant code files for the reported functionality
3. Reproduce the issue locally if possible
4. Identify the root cause

### Phase 2: Solution Development
1. Update the bug story with your findings (root cause, steps to reproduce)
2. Implement the fix following Atlas standards
3. Ensure all edge cases are handled

### Phase 3: Testing & Validation
1. Write regression tests to prevent recurrence
2. Run existing test suite to ensure no breakage
3. Document the fix in code comments

### Phase 4: Documentation & Completion
1. Update the bug story status to RESOLVED
2. Add evidence of fix (test results, screenshots if UI)
3. Prepare summary for user validation

---

## INJECTED CONTEXT AND STANDARDS

{context}

---

## IMPORTANT INSTRUCTIONS

1. **Start with the bug story**: Read and update {story_path} as you progress
2. **Follow the checklist**: Use the verification checklist above
3. **Document everything**: Update the story with findings, not just code
4. **Test thoroughly**: This is a production issue that affects users
5. **Use Atlas standards**: Follow the patterns and practices in the injected context

Begin by examining the bug story and investigating the reported issue.
"""

    return prompt

def main():
    parser = argparse.ArgumentParser(description='Atlas Bug Workflow Orchestrator')
    parser.add_argument('--description', '-d', required=True, help='Bug description')
    parser.add_argument('--area', '-a', default='General', help='App area affected')
    parser.add_argument('--severity', '-s', default='HIGH', choices=['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'])
    parser.add_argument('--output', '-o', help='Output file for the workflow prompt')

    args = parser.parse_args()

    print("\n" + "="*60)
    print("üö® ATLAS BUG WORKFLOW ORCHESTRATOR")
    print("="*60)

    # Step 1: Create bug story
    print("\nüìù Creating bug story...")
    story_path = create_bug_story(args.description, args.area)
    print(f"   ‚úÖ Story created: {story_path}")

    # Step 2: Inject context and checklist
    print("\nüîß Loading troubleshooting context...")
    context, metadata = inject_bug_context_and_checklist()
    print(f"   ‚úÖ Context loaded: {metadata['total_tokens']} tokens")
    print(f"   ‚úÖ Checklist included: {metadata.get('checklist_included', False)}")

    # Step 3: Create workflow prompt
    print("\nüìã Generating workflow prompt...")
    workflow_prompt = format_workflow_prompt(args.description, story_path, context)

    # Step 4: Output or display
    if args.output:
        with open(args.output, 'w') as f:
            f.write(workflow_prompt)
        print(f"   ‚úÖ Workflow prompt saved to: {args.output}")
    else:
        print("\n" + "="*60)
        print("WORKFLOW PROMPT FOR LLM")
        print("="*60)
        print(workflow_prompt)

    print("\n" + "="*60)
    print("‚úÖ ATLAS BUG WORKFLOW READY")
    print("="*60)
    print(f"\nüìç Bug Story: {story_path}")
    print(f"üìä Context Size: {len(context)} chars ({metadata['total_tokens']} tokens)")
    print(f"‚úÖ Checklist: Included")
    print(f"\nüöÄ The LLM now has everything needed to resolve this bug following Atlas standards!")

    return 0

if __name__ == '__main__':
    sys.exit(main())